import{createActionURL as _,Auth as E,raw as $,skipCSRFCheck as O,isAuthAction as H}from"@auth/core";import"@auth/core/errors";import{e as f}from"./fetchEvent.mjs";import{s as v,g as I}from"./utils.mjs";import k from"@auth/core/providers/github";import{PrismaAdapter as A}from"@auth/prisma-adapter";import{z as c}from"zod";import{d as D}from"./db.mjs";const R="authorizationParams-";function W(e){const n=async t=>{const r=typeof e=="object"?e:await e(t);v(process.env,r),r.basePath??=I(r);const{request:s}=t,a=new URL(s.url),d=a.pathname.slice(r.basePath.length+1).split("/")[0];return H(d)&&a.pathname.startsWith(r.basePath+"/")?E(s,r):new Response("Not Found",{status:404})};return{signIn:async t=>{const{request:r}=t,s=typeof e=="object"?e:await e(t);v(process.env,s);const a=await r.formData(),{providerId:d,...u}=Object.fromEntries(a);let l={},m={};for(const i in u)i.startsWith(R)?l[i.slice(R.length)]=u[i]:m[i]=u[i];await L(d,m,l,s,t)},signOut:async t=>{const r=typeof e=="object"?e:await e(t);v(process.env,r);const s=Object.fromEntries(await t.request.formData());await j(s,r,t)},GET:n,POST:n}}async function L(e,n={},t,r,s){const{request:a}=s,{protocol:d}=new URL(a.url),u=new Headers(a.headers),{redirect:l=!0,redirectTo:m,...i}=n instanceof FormData?Object.fromEntries(n):n,p=m?.toString()??u.get("Referer")??"/",h=_("signin",d,u,process.env,r);if(!e){const o=`${h}?${new URLSearchParams({callbackUrl:p})}`;return l&&f(s.nativeEvent,o,302),o}let w=`${h}/${e}?${new URLSearchParams(t)}`,S;for(const o of r.providers){const{id:P}=typeof o=="function"?o():o;if(P===e){S=P;break}}if(!S){const o=`${h}?${new URLSearchParams({callbackUrl:p})}`;return l&&f(s.nativeEvent,o,302),o}S==="credentials"&&(w=w.replace("signin","callback")),u.set("Content-Type","application/x-www-form-urlencoded");const y=new URLSearchParams({...i,callbackUrl:p}),g=new Request(w,{method:"POST",headers:u,body:y}),b=await E(g,{...r,raw:$,skipCSRFCheck:O});for(const o of b?.cookies??[])s.response.headers.append("set-cookie",`${o.name}=${o.value}; Path=/; ${o.options?.httpOnly?"HttpOnly;":""} ${o.options?.secure?"Secure;":""} ${o.options?.sameSite?`SameSite=${o.options.sameSite};`:""}`);return l?f(s.nativeEvent,b.redirect,302):b.redirect}async function j(e,n,t){const{request:r}=t,{protocol:s}=new URL(r.url),a=new Headers(r.headers);a.set("Content-Type","application/x-www-form-urlencoded");const d=_("signout",s,a,process.env,n),u=e?.redirectTo??a.get("Referer")??"/",l=new URLSearchParams({callbackUrl:u}),m=new Request(d,{method:"POST",headers:a,body:l}),i=await E(m,{...n,raw:$,skipCSRFCheck:O});for(const p of i?.cookies??[])t.response.headers.append("set-cookie",`${p.name}=${p.value}; Path=/; ${p.options?.httpOnly?"HttpOnly;":""} ${p.options?.secure?"Secure;":""} ${p.options?.sameSite?`SameSite=${p.options.sameSite};`:""}`);return e?.redirect??!0?f(t.nativeEvent,i.redirect,302):i}const q=c.object({NODE_ENV:c.enum(["development","production","test"]).default("development"),GITHUB_ID:c.string(),GITHUB_SECRET:c.string(),AUTH_SECRET:c.string(),AUTH_TRUST_HOST:c.string().optional(),AUTH_URL:c.string().optional(),MONGODB_URI:c.string()});c.object({MODE:c.enum(["development","production","test"]).default("development"),VITE_AUTH_PATH:c.string().optional()});const B=e=>Object.entries(e).map(([n,t])=>{if(t&&"_errors"in t)return`${n}: ${t._errors.join(", ")}
`}).filter(Boolean),T=q.safeParse(process.env);if(T.success===!1)throw console.error(`‚ùå Invalid environment variables:
`,...B(T.error.format())),new Error("Invalid environment variables");const U=T.data,J={callbacks:{session({session:e,user:n}){return e.user&&(e.user.id=n.id),e}},adapter:A(D),providers:[k({clientId:U.GITHUB_ID,clientSecret:U.GITHUB_SECRET,allowDangerousEmailAccountLinking:!0})],debug:!1,basePath:"/api/auth"};export{W as S,J as a};
